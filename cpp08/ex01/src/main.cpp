/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jode-jes <jode-jes@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 11:53:38 by joaosilva         #+#    #+#             */
/*   Updated: 2025/07/02 23:07:35 by jode-jes         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <iostream>
#include "Span.hpp"
#include <vector>
#include <cstdlib>

/* 
ex00 (Easy find):
The goal is to write a function template easyfind that searches for an integer 
in any STL container (like std::vector, std::list, etc.) using STL algorithms. 
If the value is found, it returns an iterator to it; if not, it throws an exception 
or returns an error value. This exercise is about using STL algorithms and templates.

ex01 (Span):
The goal is to implement a Span class that can store up to N integers and provides 
methods to add numbers, find the shortest span (smallest difference between any two numbers), 
and the longest span (largest difference). You must also implement a way to add
multiple numbers at once using a range of iterators. The exercise focuses on using 
STL containers, algorithms, and canonical class form.

ex02 (MutantStack):
The goal is to create a MutantStack class that inherits from std::stack and adds 
iterator support, making it possible to iterate through the stack like other STL containers. 
This exercise is about extending STL containers and working with iterators and templates.

1 - How does rand() works?
    The line bigSpan.addNumber(rand()); adds a random number to bigSpan because the 
    rand() function (from <cstdlib>) generates a pseudo-random integer each time it is called. 
    This random integer is then passed as an argument to the addNumber method, 
    which stores it in the Span object.
    The number generated by rand() is not limited to 10,000. 
    By default, rand() returns a value between 0 and RAND_MAX 
    (which is typically at least 32,767, but can be much larger depending on the system). 
    So, the numbers added can be any integer in that range, not just up to 10,000.
2 - Where is the requirement about adding a range of numbers with iterators fulfilled?
    This requirement is fulfilled here:
        s2.addNumbers(v.begin(), v.end());
    This line uses the addNumbers member function, which takes a range of iterators 
    and adds all the elements from the vector to the Span in a single call, 
    instead of calling addNumber() repeatedly. This matches the subject's request 
    to allow filling the Span using a range of iterators.
3 - What is a range of iterators?
    - A "range of iterators" refers to a pair of iterators that define the start 
        and end positions of a sequence of elements in a container (like a vector, list, etc.).
    - The first iterator points to the beginning of the range (inclusive).
        The second iterator points just past the last element of the range (exclusive).
        For example, in v.begin(), v.end(),
    - v.begin() is the iterator to the first element of the vector v.
        v.end() is the iterator just after the last element.
        This pair [begin, end) is used by many STL algorithms and functions to 
            operate on all elements in that segment of the container.
        In your code, s2.addNumbers(v.begin(), v.end()) adds all elements 
            from the vector v to the Span object s2 using this range of iterators.
4 - Accordingy with the subject and the rules, can I use std::out_of_range?
    Yes, you can use std::out_of_range in your easyfind implementation 
    according to the subject and rules.
    The subject says you can throw an exception of your choice if 
    the value is not found.
    std::out_of_range is a standard exception used by STL containers 
    (like vector::at()) when an element is not found or is out of bounds.
    It is included in <stdexcept>, which is allowed.
    There are no restrictions in the subject or rules against using std::out_of_range.
    Conclusion:
        Using throw std::out_of_range("Value not found"); is correct, 
        standard, and even slightly more precise than std::runtime_error for this case. 
        Both are accepted, but std::out_of_range is a good STL-style choice.
5 - Difference between std::runtime_error and std::out_of_range:
    std::runtime_error is a general-purpose exception for runtime errors.
    std::out_of_range is a specific exception for cases where an index or key is out of bounds.
    In this case, since we are looking for a value in a container, 
    std::out_of_range is more appropriate as it indicates the value was not found 
    within the valid range of the container.
6 - Difference between std::runtime_error and std::invalid_argument:
    std::runtime_error is a general-purpose exception for runtime errors.
    std::invalid_argument is used when an argument passed to a function is invalid.
    In this case, since we are not passing an invalid argument but rather 
    indicating that a value was not found in the container, std::runtime_error 
    or std::out_of_range would be more appropriate.
7 - Difference between std::runtime_error and std::distance:
    std::runtime_error is an exception type used to indicate runtime errors.
    std::distance is a function that calculates the distance between two iterators.
    std::distance(begin, it) gives you the index of it).
    Use std::distance if you want to know the position/index of an iterator in a container.
    They serve different purposes: std::runtime_error is for error handling, 
    while std::distance is for iterator arithmetic.
    Resume:
        Best practice here:
            std::runtime_error is perfectly acceptable and generic.
            std::invalid_argument is less appropriate, because the argument 
            is not invalidâ€”the value just wasn't found.
            std::distance is not an exception; it's a function to calculate the distance
            between two iterators, which is not relevant for this context.
            std::out_of_range is more specific and idiomatic for this case,
            as it indicates that the value was not found within the valid range of the container.
            However, std::runtime_error is also fine and idiomatic for this context.
            So, you can use either std::runtime_error or std::out_of_range.
            If you want to be even more precise, you could use std::out_of_range, 
            but std::runtime_error is totally fine and idiomatic for this context.\
8 -  ****************************
STACK IS USED IN THIS EXERCISE due 2 reasons:
1. RPN (Reverse Polish Notation) was created to use a stack.
2. Stack us usefull to make pull and push operations.
******************************
*/

int main()
{
    std::cout << std::endl;
    std::cout << "---------- SPAN 5 TESTS -----------" << std::endl;
    Span sp = Span(5);
    sp.addNumber(6);
    sp.addNumber(3);
    sp.addNumber(17);
    sp.addNumber(9);
    sp.addNumber(11);

    std::cout << "Span 5 shortest: " << sp.shortestSpan() << std::endl;
    std::cout << "Span 5 longest : " <<sp.longestSpan() << std::endl;
    
    // Test with 10,000 numbers
    std::cout << std::endl;
    std::cout << "---------- BIG SPAN TESTS -----------"<< std::endl;
    Span bigSpan(10000);
    srand(static_cast<unsigned int>(time(0))); // Seed the random number generator
    for (int i = 0; i < 10000; ++i)
        bigSpan.addNumber(rand()); // Comments above
    std::cout << "Big span shortest: " << bigSpan.shortestSpan() << std::endl;
    std::cout << "Big span longest: " << bigSpan.longestSpan() << std::endl;

    // Test addNumbers with iterators
    std::cout << std::endl;
    std::cout << "---------- VECTOR ITERATORS TESTS -----------"<< std::endl;
    std::vector<int> v;
    for (int i = 0; i < 10; ++i)
        v.push_back(i * 10);
    Span s2(10);
    s2.addNumbers(v.begin(), v.end());
    std::cout << "s2 shortest: " << s2.shortestSpan() << std::endl;
    std::cout << "s2 longest: " << s2.longestSpan() << std::endl;

    // Exception test
    try {
        s2.addNumber(42);
    } catch (std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
    }
    std::cout << std::endl;
    
    return 0;
}
